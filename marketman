#!/usr/bin/env python3
"""
MarketMan CLI - Easy command-line interface
Matches your server monitoring workflow with simple commands
"""

import sys
import argparse
from pushover_utils import send_pushover_notification, send_energy_alert, test_pushover

def main():
    parser = argparse.ArgumentParser(description="MarketMan CLI Tools")
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Test command
    test_parser = subparsers.add_parser('test', help='Test system components')
    test_parser.add_argument('--pushover', action='store_true', help='Test Pushover only')
    test_parser.add_argument('--all', action='store_true', help='Run all tests')
    
    # Monitor command
    monitor_parser = subparsers.add_parser('monitor', help='Run monitoring')
    monitor_parser.add_argument('--system', action='store_true', help='System monitoring only')
    monitor_parser.add_argument('--news', action='store_true', help='News analysis only')
    monitor_parser.add_argument('--loop', type=int, help='Run continuously (minutes)')
    
    # Send command (for manual alerts)
    send_parser = subparsers.add_parser('send', help='Send manual notification')
    send_parser.add_argument('message', help='Message to send')
    send_parser.add_argument('--title', default='MarketMan Alert', help='Notification title')
    send_parser.add_argument('--priority', type=int, default=0, help='Priority (-2 to 2)')
    
    # Service command
    service_parser = subparsers.add_parser('service', help='Service management')
    service_parser.add_argument('action', choices=['install', 'start', 'stop', 'status'], help='Service action')
    
    # Setup command
    setup_parser = subparsers.add_parser('setup', help='Setup and configuration')
    setup_parser.add_argument('--notion', action='store_true', help='Set up Notion database')
    
    # Memory command
    memory_parser = subparsers.add_parser('memory', help='Market memory operations')
    memory_parser.add_argument('--patterns', action='store_true', help='Show recent patterns')
    memory_parser.add_argument('--stats', action='store_true', help='Show memory statistics')
    memory_parser.add_argument('--etf', help='Show patterns for specific ETF')
    memory_parser.add_argument('--days', type=int, default=7, help='Days to look back (default: 7)')
    memory_parser.add_argument('--cleanup', type=int, help='Clean up data older than N days')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    if args.command == 'test':
        if args.pushover:
            print("🧪 Testing Pushover...")
            success = test_pushover()
            sys.exit(0 if success else 1)
        else:
            print("🧪 Running full test suite...")
            import test_setup
            test_setup.main()
    
    elif args.command == 'monitor':
        from marketman_monitor import MarketManMonitor
        monitor = MarketManMonitor()
        
        if args.loop:
            print(f"🔄 Starting continuous monitoring (every {args.loop} minutes)")
            # Import and run with loop
            import marketman_monitor
            sys.argv = ['marketman_monitor.py', '--loop', str(args.loop)]
            if args.system:
                sys.argv.append('--system-only')
            elif args.news:
                sys.argv.append('--news-only')
            marketman_monitor.main()
        else:
            if args.system:
                monitor.run_system_check()
            elif args.news:
                monitor.run_news_check()
            else:
                monitor.run_full_check()
    
    elif args.command == 'send':
        success = send_pushover_notification(args.message, args.title, args.priority)
        sys.exit(0 if success else 1)
    
    elif args.command == 'service':
        import subprocess
        import os
        
        service_file = '/root/marketMan/marketman.service'
        
        if args.action == 'install':
            print("📦 Installing MarketMan service...")
            subprocess.run(['cp', service_file, '/etc/systemd/system/'])
            subprocess.run(['systemctl', 'daemon-reload'])
            subprocess.run(['systemctl', 'enable', 'marketman'])
            print("✅ Service installed. Use 'marketman service start' to begin monitoring.")
        
        elif args.action in ['start', 'stop', 'status']:
            subprocess.run(['systemctl', args.action, 'marketman'])
    
    elif args.command == 'setup':
        if args.notion:
            print("🗄️ Setting up enhanced Notion database with memory support...")
            import subprocess
            subprocess.run(['python', 'notion_setup_enhanced.py', '--create'])
        else:
            print("Please specify --notion for database setup")
            sys.exit(1)
    
    elif args.command == 'memory':
        from market_memory import MarketMemory
        memory = MarketMemory()
        
        if args.cleanup is not None:
            print(f"🧹 Cleaning up data older than {args.cleanup} days...")
            result = memory.cleanup_old_data(args.cleanup)
            
            if 'error' in result:
                print(f"❌ Error during cleanup: {result['error']}")
                sys.exit(1)
            else:
                deleted_signals = result.get('deleted_signals', 0)
                deleted_patterns = result.get('deleted_patterns', 0)
                cutoff_date = result.get('cutoff_date', 'unknown')
                
                if deleted_signals + deleted_patterns > 0:
                    print(f"✅ Cleanup complete: {deleted_signals} signals and {deleted_patterns} patterns deleted")
                    print(f"   (Records older than {cutoff_date})")
                else:
                    print(f"✅ Cleanup complete: No records older than {args.cleanup} days found")
                    print(f"   (Would delete records older than {cutoff_date})")
            
        elif args.stats:
            print("📊 Memory Statistics:")
            stats = memory.get_memory_stats()
            print(f"   Total signals: {stats.get('total_signals', 0)}")
            print(f"   Recent signals (7 days): {stats.get('recent_activity', 0)}")
            
            # Show signal breakdown if available
            breakdown = stats.get('signal_breakdown', {})
            if breakdown:
                print("   Signal breakdown:")
                for signal_type, count in breakdown.items():
                    print(f"     {signal_type}: {count}")
            
            # Show date range if available
            date_range = stats.get('date_range', (None, None))
            if date_range[0] and date_range[1]:
                print(f"   Date range: {date_range[0]} to {date_range[1]}")
            
            # Get database file size
            db_path = stats.get('db_path', 'marketman_memory.db')
            try:
                import os
                if os.path.exists(db_path):
                    size_mb = os.path.getsize(db_path) / (1024 * 1024)
                    print(f"   Database size: {size_mb:.2f} MB")
                else:
                    print("   Database: Not yet created")
            except Exception as e:
                print(f"   Database size: Unable to determine ({e})")
            
            # Get active patterns count
            try:
                patterns = memory.detect_patterns()
                print(f"   Active patterns: {len(patterns)}")
            except:
                print("   Active patterns: 0")
            
        elif args.patterns or args.etf:
            etf_filter = args.etf.upper() if args.etf else None
            patterns = memory.detect_patterns(etf_symbol=etf_filter)
            
            if not patterns:
                filter_text = f" for {etf_filter}" if etf_filter else ""
                print(f"🤷 No patterns found{filter_text}")
            else:
                print(f"🧠 Recent Market Patterns:")
                for pattern in patterns:
                    print(f"   • {pattern['description']}")
        else:
            # Show recent signals by default
            signals = memory.get_recent_signals(args.days)
            if not signals:
                print(f"📭 No signals found in the last {args.days} days")
            else:
                print(f"📈 Last {len(signals)} signals ({args.days} days):")
                for signal in signals[:10]:  # Limit to 10 most recent
                    etfs_str = ", ".join(signal['etfs'][:3])  # Show first 3 ETFs
                    print(f"   • {signal['date']} - {signal['signal']} ({signal['confidence']}/10) - {etfs_str}")
                    print(f"     {signal['title'][:80]}...")
                    print()

if __name__ == "__main__":
    main()
